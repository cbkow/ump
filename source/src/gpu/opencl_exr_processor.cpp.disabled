#include "opencl_exr_processor.h"
#include "../utils/debug_utils.h"
#include "../player/exr_frame_cache.h"
#include <chrono>
#include <algorithm>

namespace UnionPlayer {

    OpenCLEXRProcessor::OpenCLEXRProcessor() {
        Debug::Log("OpenCLEXRProcessor: Constructor called");
    }

    OpenCLEXRProcessor::~OpenCLEXRProcessor() {
        Shutdown();
    }

    bool OpenCLEXRProcessor::Initialize(const OpenCLConfig& config) {
        if (is_initialized_) {
            Debug::Log("OpenCLEXRProcessor: Already initialized");
            return true;
        }

        if (!config.IsValid()) {
            Debug::Log("OpenCLEXRProcessor: Invalid configuration");
            return false;
        }

        config_ = config;

        if (!config_.enable_compute_acceleration) {
            Debug::Log("OpenCLEXRProcessor: Compute acceleration disabled in config");
            return false;
        }

        if (!IsOpenCLAvailable()) {
            Debug::Log("OpenCLEXRProcessor: OpenCL not available on this system");
            return false;
        }

        if (!InitializeOpenCL()) {
            Debug::Log("OpenCLEXRProcessor: Failed to initialize OpenCL");
            return false;
        }

        Debug::Log("OpenCLEXRProcessor: Successfully initialized with device: " + current_device_.name);
        is_initialized_ = true;
        return true;
    }

    void OpenCLEXRProcessor::Shutdown() {
        if (!is_initialized_) {
            return;
        }

        CleanupOpenCL();
        is_initialized_ = false;
        Debug::Log("OpenCLEXRProcessor: Shutdown complete");
    }

    bool OpenCLEXRProcessor::InitializeOpenCL() {
#ifdef OPENCL_AVAILABLE
        // Get available platforms
        cl_uint num_platforms;
        cl_int error = clGetPlatformIDs(0, nullptr, &num_platforms);
        if (!CheckOpenCLError(error, "clGetPlatformIDs") || num_platforms == 0) {
            Debug::Log("OpenCLEXRProcessor: No OpenCL platforms found");
            return false;
        }

        std::vector<cl_platform_id> platforms(num_platforms);
        error = clGetPlatformIDs(num_platforms, platforms.data(), nullptr);
        if (!CheckOpenCLError(error, "clGetPlatformIDs")) {
            return false;
        }

        // Find best device across all platforms
        std::vector<cl_device_id> all_devices;
        for (cl_platform_id platform : platforms) {
            cl_uint num_devices;
            error = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, nullptr, &num_devices);
            if (error != CL_SUCCESS || num_devices == 0) {
                continue;
            }

            std::vector<cl_device_id> platform_devices(num_devices);
            error = clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, num_devices, platform_devices.data(), nullptr);
            if (error == CL_SUCCESS) {
                all_devices.insert(all_devices.end(), platform_devices.begin(), platform_devices.end());
            }
        }

        if (all_devices.empty()) {
            Debug::Log("OpenCLEXRProcessor: No GPU devices found");
            return false;
        }

        // Select best device
        device_ = SelectBestDevice(all_devices);
        if (!device_) {
            Debug::Log("OpenCLEXRProcessor: Failed to select a suitable device");
            return false;
        }

        // Store device info
        current_device_.device_id = device_;
        current_device_.is_nvidia = IsDeviceNVIDIA(device_);
        current_device_.supports_gl_sharing = SupportsGLSharing(device_);

        // Get device name
        size_t name_size;
        clGetDeviceInfo(device_, CL_DEVICE_NAME, 0, nullptr, &name_size);
        std::vector<char> name_buffer(name_size);
        clGetDeviceInfo(device_, CL_DEVICE_NAME, name_size, name_buffer.data(), nullptr);
        current_device_.name = std::string(name_buffer.data());

        // Get device vendor
        size_t vendor_size;
        clGetDeviceInfo(device_, CL_DEVICE_VENDOR, 0, nullptr, &vendor_size);
        std::vector<char> vendor_buffer(vendor_size);
        clGetDeviceInfo(device_, CL_DEVICE_VENDOR, vendor_size, vendor_buffer.data(), nullptr);
        current_device_.vendor = std::string(vendor_buffer.data());

        Debug::Log("OpenCLEXRProcessor: Selected device: " + current_device_.name + " (" + current_device_.vendor + ")");

        // Create context and command queue
        if (!CreateContext() || !CreateCommandQueue()) {
            return false;
        }

        // Load kernels
        if (!LoadKernels()) {
            return false;
        }

        // Create initial buffers for common frame sizes (4K)
        size_t initial_buffer_size = 3840 * 2160 * 4 * sizeof(float);
        if (!CreateBuffers(initial_buffer_size)) {
            return false;
        }

        return true;
#else
        Debug::Log("OpenCLEXRProcessor: OpenCL not available at compile time");
        return false;
#endif
    }

    bool OpenCLEXRProcessor::CreateContext() {
        cl_int error;

        // Create context with OpenGL sharing if supported
        if (current_device_.supports_gl_sharing) {
            // TODO: Implement OpenGL sharing context creation
            Debug::Log("OpenCLEXRProcessor: OpenGL sharing supported but not yet implemented");
        }

        // Create basic context
        context_ = clCreateContext(nullptr, 1, &device_, nullptr, nullptr, &error);
        if (!CheckOpenCLError(error, "clCreateContext")) {
            return false;
        }

        Debug::Log("OpenCLEXRProcessor: OpenCL context created successfully");
        return true;
    }

    bool OpenCLEXRProcessor::CreateCommandQueue() {
        cl_int error;

        // Create command queue with profiling enabled
        queue_ = clCreateCommandQueue(context_, device_, CL_QUEUE_PROFILING_ENABLE, &error);
        if (!CheckOpenCLError(error, "clCreateCommandQueue")) {
            return false;
        }

        Debug::Log("OpenCLEXRProcessor: OpenCL command queue created successfully");
        return true;
    }

    bool OpenCLEXRProcessor::LoadKernels() {
        std::string kernel_source = GetKernelSource();
        if (kernel_source.empty()) {
            Debug::Log("OpenCLEXRProcessor: Failed to get kernel source");
            return false;
        }

        cl_int error;
        const char* source_ptr = kernel_source.c_str();
        size_t source_size = kernel_source.length();

        program_ = clCreateProgramWithSource(context_, 1, &source_ptr, &source_size, &error);
        if (!CheckOpenCLError(error, "clCreateProgramWithSource")) {
            return false;
        }

        // Build program
        error = clBuildProgram(program_, 1, &device_, "-cl-fast-relaxed-math", nullptr, nullptr);
        if (error != CL_SUCCESS) {
            // Get build log
            size_t log_size;
            clGetProgramBuildInfo(program_, device_, CL_PROGRAM_BUILD_LOG, 0, nullptr, &log_size);
            std::vector<char> log_buffer(log_size);
            clGetProgramBuildInfo(program_, device_, CL_PROGRAM_BUILD_LOG, log_size, log_buffer.data(), nullptr);

            Debug::Log("OpenCLEXRProcessor: Kernel build failed: " + std::string(log_buffer.data()));
            return false;
        }

        // Create kernels
        pixel_conversion_kernel_ = clCreateKernel(program_, "process_exr_pixels", &error);
        if (!CheckOpenCLError(error, "clCreateKernel(process_exr_pixels)")) {
            return false;
        }

        Debug::Log("OpenCLEXRProcessor: Kernels loaded successfully");
        return true;
    }

    bool OpenCLEXRProcessor::CreateBuffers(size_t max_frame_size) {
        cl_int error;

        // Create input buffer for half-precision RGBA data
        input_buffer_ = clCreateBuffer(context_, CL_MEM_READ_ONLY, max_frame_size, nullptr, &error);
        if (!CheckOpenCLError(error, "clCreateBuffer(input)")) {
            return false;
        }

        // Create output buffer for float-precision RGBA data
        output_buffer_ = clCreateBuffer(context_, CL_MEM_WRITE_ONLY, max_frame_size, nullptr, &error);
        if (!CheckOpenCLError(error, "clCreateBuffer(output)")) {
            return false;
        }

        buffer_size_ = max_frame_size;
        Debug::Log("OpenCLEXRProcessor: Created buffers for " + std::to_string(max_frame_size) + " bytes");
        return true;
    }

    bool OpenCLEXRProcessor::ProcessFrame(const EXRProcessedData& cpu_data, GLuint& gpu_texture) {
        if (!is_initialized_ || !cpu_data.is_valid || cpu_data.pixels.empty()) {
            return false;
        }

        auto start_time = std::chrono::steady_clock::now();

        // Check if we need to resize buffers
        size_t required_size = cpu_data.width * cpu_data.height * 4 * sizeof(float);
        if (required_size > buffer_size_) {
            CleanupOpenCL();
            if (!CreateBuffers(required_size * 2)) { // 2x for future growth
                return false;
            }
        }

        // Process pixels on GPU
        std::vector<float> output_pixels(cpu_data.width * cpu_data.height * 4);
        if (!ProcessPixelsOnGPU(cpu_data, output_pixels.data())) {
            return false;
        }

        // Upload to OpenGL texture (placeholder - will integrate with texture pool)
        // TODO: Integrate with existing texture pool system
        gpu_texture = 0; // Placeholder

        auto end_time = std::chrono::steady_clock::now();
        auto processing_time = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();

        UpdateStats(processing_time);
        return true;
    }

    bool OpenCLEXRProcessor::ProcessPixelsOnGPU(const EXRProcessedData& cpu_data, float* output_pixels) {
        cl_int error;

        // Upload input data
        error = clEnqueueWriteBuffer(queue_, input_buffer_, CL_FALSE, 0,
                                   cpu_data.pixels.size() * sizeof(half),
                                   cpu_data.pixels.data(), 0, nullptr, nullptr);
        if (!CheckOpenCLError(error, "clEnqueueWriteBuffer")) {
            return false;
        }

        // Set kernel arguments
        cl_int width = cpu_data.width;
        cl_int height = cpu_data.height;
        cl_float exposure_multiplier = 1.0f; // Default exposure

        error = clSetKernelArg(pixel_conversion_kernel_, 0, sizeof(cl_mem), &input_buffer_);
        error |= clSetKernelArg(pixel_conversion_kernel_, 1, sizeof(cl_mem), &output_buffer_);
        error |= clSetKernelArg(pixel_conversion_kernel_, 2, sizeof(cl_int), &width);
        error |= clSetKernelArg(pixel_conversion_kernel_, 3, sizeof(cl_int), &height);
        error |= clSetKernelArg(pixel_conversion_kernel_, 4, sizeof(cl_float), &exposure_multiplier);

        if (!CheckOpenCLError(error, "clSetKernelArg")) {
            return false;
        }

        // Execute kernel
        size_t global_work_size = cpu_data.width * cpu_data.height;
        size_t local_work_size = std::min<size_t>(256, current_device_.max_work_group_size);

        error = clEnqueueNDRangeKernel(queue_, pixel_conversion_kernel_, 1, nullptr,
                                     &global_work_size, &local_work_size, 0, nullptr, nullptr);
        if (!CheckOpenCLError(error, "clEnqueueNDRangeKernel")) {
            return false;
        }

        // Read back results
        error = clEnqueueReadBuffer(queue_, output_buffer_, CL_TRUE, 0,
                                  global_work_size * 4 * sizeof(float),
                                  output_pixels, 0, nullptr, nullptr);
        if (!CheckOpenCLError(error, "clEnqueueReadBuffer")) {
            return false;
        }

        return true;
    }

    std::string OpenCLEXRProcessor::GetKernelSource() const {
        return R"(
__kernel void process_exr_pixels(
    __global const half4* input_pixels,
    __global float4* output_pixels,
    const int width,
    const int height,
    const float exposure_multiplier
) {
    int gid = get_global_id(0);
    if (gid >= width * height) return;

    // Load input pixel
    half4 input = input_pixels[gid];

    // Convert half to float with exposure adjustment
    float4 output;
    output.x = vload_half(gid * 4 + 0, (__global half*)input_pixels) * exposure_multiplier;
    output.y = vload_half(gid * 4 + 1, (__global half*)input_pixels) * exposure_multiplier;
    output.z = vload_half(gid * 4 + 2, (__global half*)input_pixels) * exposure_multiplier;
    output.w = vload_half(gid * 4 + 3, (__global half*)input_pixels);

    output_pixels[gid] = output;
}
)";
    }

    void OpenCLEXRProcessor::CleanupOpenCL() {
        if (pixel_conversion_kernel_) {
            clReleaseKernel(pixel_conversion_kernel_);
            pixel_conversion_kernel_ = nullptr;
        }

        if (input_buffer_) {
            clReleaseMemObject(input_buffer_);
            input_buffer_ = nullptr;
        }

        if (output_buffer_) {
            clReleaseMemObject(output_buffer_);
            output_buffer_ = nullptr;
        }

        if (program_) {
            clReleaseProgram(program_);
            program_ = nullptr;
        }

        if (queue_) {
            clReleaseCommandQueue(queue_);
            queue_ = nullptr;
        }

        if (context_) {
            clReleaseContext(context_);
            context_ = nullptr;
        }

        buffer_size_ = 0;
    }

    bool OpenCLEXRProcessor::IsOpenCLAvailable() {
#ifdef OPENCL_AVAILABLE
        cl_uint num_platforms;
        cl_int error = clGetPlatformIDs(0, nullptr, &num_platforms);
        return (error == CL_SUCCESS && num_platforms > 0);
#else
        return false;
#endif
    }

    std::vector<std::string> OpenCLEXRProcessor::GetAvailableDeviceNames() {
        std::vector<std::string> device_names;

        cl_uint num_platforms;
        if (clGetPlatformIDs(0, nullptr, &num_platforms) != CL_SUCCESS || num_platforms == 0) {
            return device_names;
        }

        std::vector<cl_platform_id> platforms(num_platforms);
        if (clGetPlatformIDs(num_platforms, platforms.data(), nullptr) != CL_SUCCESS) {
            return device_names;
        }

        for (cl_platform_id platform : platforms) {
            cl_uint num_devices;
            if (clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 0, nullptr, &num_devices) != CL_SUCCESS || num_devices == 0) {
                continue;
            }

            std::vector<cl_device_id> devices(num_devices);
            if (clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, num_devices, devices.data(), nullptr) != CL_SUCCESS) {
                continue;
            }

            for (cl_device_id device : devices) {
                size_t name_size;
                if (clGetDeviceInfo(device, CL_DEVICE_NAME, 0, nullptr, &name_size) == CL_SUCCESS) {
                    std::vector<char> name_buffer(name_size);
                    if (clGetDeviceInfo(device, CL_DEVICE_NAME, name_size, name_buffer.data(), nullptr) == CL_SUCCESS) {
                        device_names.push_back(std::string(name_buffer.data()));
                    }
                }
            }
        }

        return device_names;
    }

    bool OpenCLEXRProcessor::IsDeviceNVIDIA(cl_device_id device) const {
        size_t vendor_size;
        if (clGetDeviceInfo(device, CL_DEVICE_VENDOR, 0, nullptr, &vendor_size) != CL_SUCCESS) {
            return false;
        }

        std::vector<char> vendor_buffer(vendor_size);
        if (clGetDeviceInfo(device, CL_DEVICE_VENDOR, vendor_size, vendor_buffer.data(), nullptr) != CL_SUCCESS) {
            return false;
        }

        std::string vendor(vendor_buffer.data());
        return vendor.find("NVIDIA") != std::string::npos;
    }

    bool OpenCLEXRProcessor::SupportsGLSharing(cl_device_id device) const {
        // Check for OpenGL sharing extension
        size_t extensions_size;
        if (clGetDeviceInfo(device, CL_DEVICE_EXTENSIONS, 0, nullptr, &extensions_size) != CL_SUCCESS) {
            return false;
        }

        std::vector<char> extensions_buffer(extensions_size);
        if (clGetDeviceInfo(device, CL_DEVICE_EXTENSIONS, extensions_size, extensions_buffer.data(), nullptr) != CL_SUCCESS) {
            return false;
        }

        std::string extensions(extensions_buffer.data());
        return extensions.find("cl_khr_gl_sharing") != std::string::npos;
    }

    cl_device_id OpenCLEXRProcessor::SelectBestDevice(const std::vector<cl_device_id>& devices) const {
        cl_device_id best_device = nullptr;
        int best_score = -1;

        for (cl_device_id device : devices) {
            int score = 0;

            // Prefer NVIDIA if requested and available
            if (config_.prefer_nvidia_cuda && IsDeviceNVIDIA(device)) {
                score += 100;
            }

            // Check compute units
            cl_uint compute_units;
            if (clGetDeviceInfo(device, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(compute_units), &compute_units, nullptr) == CL_SUCCESS) {
                score += compute_units;
            }

            // Prefer devices with OpenGL sharing
            if (SupportsGLSharing(device)) {
                score += 50;
            }

            if (score > best_score) {
                best_score = score;
                best_device = device;
            }
        }

        return best_device;
    }

    bool OpenCLEXRProcessor::CheckOpenCLError(cl_int error, const std::string& operation) const {
        if (error != CL_SUCCESS) {
            Debug::Log("OpenCLEXRProcessor: " + operation + " failed with error: " + GetOpenCLErrorString(error));
            return false;
        }
        return true;
    }

    std::string OpenCLEXRProcessor::GetOpenCLErrorString(cl_int error) const {
        switch (error) {
            case CL_SUCCESS: return "Success";
            case CL_DEVICE_NOT_FOUND: return "Device not found";
            case CL_DEVICE_NOT_AVAILABLE: return "Device not available";
            case CL_COMPILER_NOT_AVAILABLE: return "Compiler not available";
            case CL_MEM_OBJECT_ALLOCATION_FAILURE: return "Memory object allocation failure";
            case CL_OUT_OF_RESOURCES: return "Out of resources";
            case CL_OUT_OF_HOST_MEMORY: return "Out of host memory";
            case CL_PROFILING_INFO_NOT_AVAILABLE: return "Profiling info not available";
            case CL_MEM_COPY_OVERLAP: return "Memory copy overlap";
            case CL_IMAGE_FORMAT_MISMATCH: return "Image format mismatch";
            case CL_IMAGE_FORMAT_NOT_SUPPORTED: return "Image format not supported";
            case CL_BUILD_PROGRAM_FAILURE: return "Build program failure";
            case CL_MAP_FAILURE: return "Map failure";
            case CL_INVALID_VALUE: return "Invalid value";
            case CL_INVALID_DEVICE_TYPE: return "Invalid device type";
            case CL_INVALID_PLATFORM: return "Invalid platform";
            case CL_INVALID_DEVICE: return "Invalid device";
            case CL_INVALID_CONTEXT: return "Invalid context";
            case CL_INVALID_QUEUE_PROPERTIES: return "Invalid queue properties";
            case CL_INVALID_COMMAND_QUEUE: return "Invalid command queue";
            case CL_INVALID_HOST_PTR: return "Invalid host pointer";
            case CL_INVALID_MEM_OBJECT: return "Invalid memory object";
            case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR: return "Invalid image format descriptor";
            case CL_INVALID_IMAGE_SIZE: return "Invalid image size";
            case CL_INVALID_SAMPLER: return "Invalid sampler";
            case CL_INVALID_BINARY: return "Invalid binary";
            case CL_INVALID_BUILD_OPTIONS: return "Invalid build options";
            case CL_INVALID_PROGRAM: return "Invalid program";
            case CL_INVALID_PROGRAM_EXECUTABLE: return "Invalid program executable";
            case CL_INVALID_KERNEL_NAME: return "Invalid kernel name";
            case CL_INVALID_KERNEL_DEFINITION: return "Invalid kernel definition";
            case CL_INVALID_KERNEL: return "Invalid kernel";
            case CL_INVALID_ARG_INDEX: return "Invalid argument index";
            case CL_INVALID_ARG_VALUE: return "Invalid argument value";
            case CL_INVALID_ARG_SIZE: return "Invalid argument size";
            case CL_INVALID_KERNEL_ARGS: return "Invalid kernel arguments";
            case CL_INVALID_WORK_DIMENSION: return "Invalid work dimension";
            case CL_INVALID_WORK_GROUP_SIZE: return "Invalid work group size";
            case CL_INVALID_WORK_ITEM_SIZE: return "Invalid work item size";
            case CL_INVALID_GLOBAL_OFFSET: return "Invalid global offset";
            case CL_INVALID_EVENT_WAIT_LIST: return "Invalid event wait list";
            case CL_INVALID_EVENT: return "Invalid event";
            case CL_INVALID_OPERATION: return "Invalid operation";
            case CL_INVALID_GL_OBJECT: return "Invalid GL object";
            case CL_INVALID_BUFFER_SIZE: return "Invalid buffer size";
            case CL_INVALID_MIP_LEVEL: return "Invalid mip level";
            case CL_INVALID_GLOBAL_WORK_SIZE: return "Invalid global work size";
            default: return "Unknown error (" + std::to_string(error) + ")";
        }
    }

    void OpenCLEXRProcessor::UpdateStats(size_t processing_time_ms) {
        stats_.frames_processed++;
        stats_.total_processing_time_ms += processing_time_ms;
        stats_.average_processing_time_ms = stats_.total_processing_time_ms / stats_.frames_processed;
        stats_.opencl_active = true;
        stats_.active_device_name = current_device_.name;
    }

    OpenCLStats OpenCLEXRProcessor::GetStats() const {
        return stats_;
    }

    void OpenCLEXRProcessor::ResetStats() {
        stats_ = OpenCLStats{};
    }

    void OpenCLEXRProcessor::SetConfig(const OpenCLConfig& config) {
        if (config.IsValid()) {
            config_ = config;
        }
    }

    bool OpenCLEXRProcessor::ProcessFrameAsync(const EXRProcessedData& cpu_data, GLuint& gpu_texture) {
        // TODO: Implement asynchronous processing
        return ProcessFrame(cpu_data, gpu_texture);
    }

    std::vector<OpenCLDeviceInfo> OpenCLEXRProcessor::GetAvailableDevices() const {
        // TODO: Implement device enumeration
        return {};
    }

    bool OpenCLEXRProcessor::SelectDevice(const std::string& device_name) {
        // TODO: Implement device selection by name
        return true;
    }

} // namespace UnionPlayer